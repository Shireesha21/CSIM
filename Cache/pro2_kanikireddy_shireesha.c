
/* Project #2; Kanikireddy, Shireesha */
/* simulate an M/M/1 queue
  (an open queue with exponential service times and interarrival intervals)
*/

//Includes all the necessary header files 
#include <csim.h>
#include <stdio.h>
//Defined the constant values
#define SIMTIME 1000        /* Simulation time */
#define NUM_NODES 5         /* Number of Nodes is 5*/
#define TIME_OUT 2.0        /* If the sender does not receive the Hello_Ack packet within a timeout period */
#define PROCESSING_TIME 0.2     /*The processing time should not exceed 0.2*/
#define TRANSMISSION_TIME 0.1    /* The time taken to transmit the packet*/
#define REQUEST 1L              /* The Sender sends Hello Request */
#define REPLY 2L                /* The Receiver sends the REPLY as HELLO_ACK*/
#define INTER_ARRIVAL_TIME 5.0     

/*The structure of the message to send consits of all the below values*/
typedef struct message *msg_t;
struct message{
    long type;
    long from;
    long to;
    msg_t link;
    long count;
    TIME start_time;
};

/*The Structure of Node*/
typedef struct nde{
    FACILITY facility_cpu;              /*pointer for facility */
    MBOX mbox;                          /*Mailbox*/
}node_t;

msg_t message_queue;
node_t node[NUM_NODES];
FACILITY network[NUM_NODES][NUM_NODES];   
TABLE response_time;

long successful_transmission, failure_transmission, total_transmission;
double loss_probability_threshold=0.3;
long node1, node2, node3, node4, node5;

void initialization();
void proc();
void send_message();
void reply_message();
void return_message();
void decode_message();
msg_t new_message();
void count_message();

void sim(){
    printf("Enter the loss probability to be calculated \n: ");
    scanf("%lf", &loss_probability_threshold);

    // The process is created 
    create("simulatio_start");
    initialization();
    hold(SIMTIME);

    printf("The loss probability for : %lf is as below\n", loss_probability_threshold);
    printf("Average number of successful transmissions %.2f\n", successful_transmission/(float)total_transmission);
    printf("Average number of failure transmissions %.2f\n", failure_transmission/(float)total_transmission);
    printf("The number of packets generated by Node 1 = %ld \n", node1);
    printf("The number of packets generated by Node 2 = %ld \n", node2);
    printf("The number of packets generated by Node 3 = %ld \n", node3);
    printf("The number of packets generated by Node 4 = %ld \n", node4);
    printf("The number of packets generated by Node 5 = %ld \n", node5);
}


/*
    This function initializes the simulation by setting up the necessary entities and parameters
    such as facilities, mailboxes, events, and tables.
    It also creates the necessary nodes and network connections using a loop and initializes them.
    The parameters used are:
    i, j: integer variables used as loop counters.
    str: character array used to store strings.
*/
void initialization(){
    int i,j;
    char str[24];

    max_facilities(NUM_NODES*NUM_NODES+NUM_NODES);
    max_servers(NUM_NODES*NUM_NODES+NUM_NODES);
    max_mailboxes(NUM_NODES);
    max_events(2*NUM_NODES*NUM_NODES);
    response_time = table("Response Time of the message");
    message_queue = NIL;
    
    for(i=0;i<NUM_NODES;i++){
        sprintf(str, "facility_cpu.%d",i);
        node[i].facility_cpu = facility(str);
        sprintf(str,"input.%d",i);
        node[i].mbox = mailbox(str);
    }

    for(i=0;i<NUM_NODES;i++){
        for(j=0;j<NUM_NODES;j++){
            sprintf(str,"nt%d.%d",i,j);
            network[i][j] = facility(str);
        }
    }

    for(i=0;i<NUM_NODES;i++){
        proc(i);
    }
}


/*
This function simulates the behavior of a node.
It generates messages with an exponential inter-arrival time.
The message is transmitted to the target node and waits for the response.
If the response is not received within a certain time, the message is re-transmitted with an exponential backoff time.
The function also generates a random loss probability for each message to simulate packet loss in the network.
The function counts the number of successful transmissions, failure transmissions, and total transmissions.
@param n: the index of the node being simulated.
*/
void proc(long n){
    msg_t m;
    long sending_message, type_of_message;
    
    // Create a new process called Proc and wait for a random time interval
    create("proc");
    //It is used to hold the execution of the program
    hold(exponential(INTER_ARRIVAL_TIME));
    m = new_message(n);
    m->count = 1;
    printf("The Sender Node%d transmits a HELLO-%d packet to Node%d at %6.3f seconds\n ", m->from, m->count, m->to, m->start_time);
    send_message(m);
    count_message("Generate Message",m);

    // Continue generating and receiving messages until simulation time is reached
    while(clock<SIMTIME){
        sending_message= timed_receive(node[n].mbox, (long *)&m, TIME_OUT);
        switch(sending_message){
             // Handle the case where a message has not been received within the time frame
            case TIMED_OUT:
                /* It checks whether the sender received HELLO_ACK packet or not for two time if it is not received then it is discarded and new packet is generated */
                if(m->count>=2.0){
                    hold(exponential(INTER_ARRIVAL_TIME)); // It waits until the INTER_ARRIVAL_TIME
                    m = new_message(n);
                    m->count = 1;
                    printf("The Sender Node%d Re-Transmits the HELLO-%d at %6.3f seconds\n",m->from, m->count, m->to, clock);
                    send_message(m);
                    count_message("Generate Message",m);
                    failure_transmission++;  //Failure Count Incremented
                    total_transmission++;    //Total Transmissions to the Server
                }
                else{
                    m->count +=1.0;
                    printf("The Sender Node%d Re-Transmits the HELLO-%d at %6.3f seconds\n",m->from, m->count, m->to, clock);
                    send_message(m);
                }
                break;
            case EVENT_OCCURRED:
                type_of_message = m->type;
                switch(type_of_message){
                    case REQUEST:
                        reply_message(m);
                        double loss_probability = uniform(0.0,0.5);
                        /*It checks whether the random loss_probability is lessthan the threshold or not*/
                        if(loss_probability<=loss_probability_threshold){
			                send_message(m);
                            printf("Node%d Returns the request HELLO_ACK-%d to Node%d at %6.3f seconds\n",m->from, m->count, m->to, clock);
                            send_message(m);
                        }
                        break;
                    case REPLY:
                    /*Records the start Time taken*/
                    record(clock - m->start_time, response_time);
                    return_message(m);
                    successful_transmission++;
                    total_transmission++;
                    printf("Node%d Receives a reply HELLO_ACK-%d from Node%d at %6.3f seconds\n", m->to, m->count, m->from, clock);
                    break;
                    default:
                    printf("Unexpected Type");
                    break;
                }
            break;
        }
    }
}

void count_message(char *str, msg_t m){
    long node_num = m->from;
    if(node_num==1){
        node1++;
    }else if(node_num==2){
        node2++;
    }else if(node_num==3){
        node3++;
    }else if(node_num==4){
        node4++;
    }else if(node_num==5){
        node5++;
    }else{
	printf("Invalid Node");
    }
}


void send_message(msg_t m){
    long from = m->from;
    long to = m->to;

    reserve(network[from][to]);
    hold(TRANSMISSION_TIME);
    send(node[to].mbox, (long)m);
    release(network[from][to]);
}

msg_t new_message(long from){
    msg_t m;
    long i;
    
    if(message_queue==NIL){
        m =(msg_t)do_malloc(sizeof(struct message));
    }else{
        m = message_queue;
        message_queue = message_queue->link;
    }

    do{
        i = random(0L, NUM_NODES-1);
    }while(i==from);

    m->to = i;
    m->from = from;
    m->type = REQUEST;
    m->start_time = clock;
    return m;
}

/*The Message is*/
void return_message(msg_t m){
    m->link = message_queue;
    message_queue = m;
}

/*This method is used to Reply the Message Back*/
void reply_message(msg_t m){
    long from = m->from;
    long to = m->to;
    m->from =to;
    m->to = from;
    m->type = REPLY;
    /*Here the Facility is utilized  till the Processing Time*/
    use(node[to].facility_cpu, PROCESSING_TIME);
}

/*Used for debugging the code*/
/*void decode_msg(char *message, msg_t messageType, long n){
    if(messageType->type == REPLY)
        printf("node.%ld %message from node.&ld at %6.3f seconds\n", messageType->from, messageType->to, message, clock);
    printf("node.%ld %message to node.&ld at %6.3f seconds\n", messageType->from, messageType->to, message, clock);
}*/